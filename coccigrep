#!/usr/bin/python
# Copyright (C) 2011 Eric Leblond <eric@regit.org>
#
# You can copy, redistribute or modify this Program under the terms of
# the GNU General Public License version 3 as published by the Free
# Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# version 3 along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA.


from subprocess import call, Popen, PIPE
from tempfile import NamedTemporaryFile
from os import unlink
import argparse
from sys import exit

use_pigments = True

try:
    from pygments import highlight
    from pygments.lexers import CLexer
    from pygments.formatters import Terminal256Formatter, HtmlFormatter
except:
    use_pigments = False

SPATCH="spatch"

cocci_smpl = {}

cocci_smpl['used']="""@init@
typedef %s;
%s *p;
position p1;
@@

p@p1
"""

cocci_smpl['deref']="""@init@
typedef %s;
%s *p;
position p1;
@@

p->%s@p1
"""

cocci_smpl['set']="""@init@
typedef %s;
%s *p;
expression E;
position p1;
@@

(
p->%s@p1 |= E
|
p->%s@p1 = E
|
p->%s@p1 += E
|
p->%s@p1 -= E
)
"""

cocci_smpl['test']="""@init@
typedef %s;
%s *p;
expression E;
position p1;
@@

(
p->%s@p1 == E
|
p->%s@p1 != E
|
p->%s@p1 & E
|
p->%s@p1 < E
|
p->%s@p1 <= E
|
p->%s@p1 > E
|
p->%s@p1 >= E
)
"""

cocci_python="""

@ script:python @
p1 << init.p1;
@@

for p in p1:
    print "%s:%s:%s" % (p.file,p.line,p.column)
"""

parser = argparse.ArgumentParser(prog='coccigrep', description='Semantic grep based on coccinelle')
parser.add_argument('-t', '--type', default=None, help='C type where looking for')
parser.add_argument('-a', '--attribut', default=None, help='C attribut that is set')
parser.add_argument('-o', '--operation', default='used', help='Operation on structure', choices=['used', 'test', 'set'])
parser.add_argument('-A', '--after-context', dest='after', type=int, default=0, help='Number of line after context')
parser.add_argument('-B', '--before-context', dest='before', type=int, default=0, help='Number of line before context')
parser.add_argument('-c', '--color', action='store_const', const=True, help='colorize output (need pigments)')
parser.add_argument('-f', '--output-format', dest='oformat', default='term', help='colorize format for output', choices=['term', 'html'])
parser.add_argument('-v', '--verbose', action='store_const', const=True, help='verbose output (including coccinelle error)')
parser.add_argument('file', metavar='file', nargs='+', help='List of files')
parser.add_argument('--version', action='version', version='%(prog)s 0.3')

args = parser.parse_args()

# create tmp cocci file:
tmp_cocci_file = NamedTemporaryFile(suffix=".cocci", delete=False)
tmp_cocci_file_name = tmp_cocci_file.name


if args.operation == 'set':
    cocci_grep = cocci_smpl['set'] % (args.type, args.type, args.attribut, args.attribut, args.attribut, args.attribut) + cocci_python
elif args.operation == 'test':
    cocci_grep = cocci_smpl['test'] % (args.type, args.type, args.attribut, args.attribut, args.attribut, args.attribut, args.attribut, args.attribut, args.attribut) + cocci_python
elif args.operation == 'used':
    if args.attribut:
        cocci_grep = cocci_smpl['deref'] % (args.type, args.type, args.attribut) + cocci_python
    else:
        cocci_grep = cocci_smpl['used'] % (args.type, args.type) + cocci_python
else:
    print "unknown method"
    exit(1)

tmp_cocci_file.write(cocci_grep)
tmp_cocci_file.close()

# launch spatch
cmd = [SPATCH, "-sp_file", tmp_cocci_file.name] + args.file

if args.verbose:
    print "Running: %s." % " ".join(cmd)
    output = Popen(cmd, stdout=PIPE).communicate()[0]
else:
    output = Popen(cmd, stdout=PIPE, stderr=PIPE).communicate()[0]

unlink(tmp_cocci_file_name)

display = ""
prevfile = None
prevline = None
for ematch in output.split("\n"):
    try:
        (efile, eline, ecol) = ematch.split(":")
        # if there is equality then we will already display the line
        if (efile == prevfile) and (eline == prevline):
            continue
        else:
            prevfile = efile
            prevline = eline
        f = open(efile, 'r')
        lines = f.readlines()
        if args.color:
            display += "%s: l.%s -%d, l.%s +%d \n" % (efile, eline, args.before, eline, args.after)
        for i in range(int(eline) - 1 - args.before, int(eline) + args.after):
            if args.color:
                display += lines[i]
            else:
                print "%s:%s: %s" % (efile, eline, lines[i].rstrip())
        f.close()
    except ValueError:
        pass

if args.color:
    if use_pigments:
        if args.oformat == "term":
            print highlight(display, CLexer(), Terminal256Formatter())
        elif args.oformat == "html":
            print highlight(display, CLexer(), HtmlFormatter())
    else:
        print display
